---
title: "Parallel, Multiple, and Unpacking Assignment"
author: "Nathan Teetor"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Parallel, Multiple, and Unpacking Assignment}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{R, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = '#>')
knitr::knit_theme$set('leo')

library(allotalot)
```

## Parallel Assignment

Parallel assignment is the assignment of multiple variables at once. Languages, such as Python or Go, allow parallel or unpacking assignment with syntax similar to the following.

```{python, comment = '#>>>'}
a, b = 0, 1

print(a)
print(b)
```
```{python, comment = '#>>>'}
c, d = 'red', 'fish'

print(c)
print(d)
```
```{python, comment = '#>>>'}
values = ['a', 'simple', 'list']

e, f, g = values

print(e)
print(f)
print(g)
```

In the above example we see `a` and `b` assigned on a single line, likewise `c` and `d`, and in the final example we unpack a list of values into `e`, `f`, and `g`. R allows a watered-down version of these examples, but variables must be assigned the same value. 

```{R}
a <- b <- c(0, 1)

a

b
```

```{R}
c <- d <- c('red', 'fish')

c

d
```

```{R}
e <- f <- g <- list('a', 'simple', 'list')

e
```

Now that we have seen a couple initial examples and touched on the limitations of R, we will quickly preview the tools *allotalot* provides and then look at a series of more complex and practical parallel assignment examples.

## Toolset

When we talk about a parallel assignment expression there are three components we often refer to,

1. The operator
2. The left-hand side, i.e. the variable names
3. The right-hand side, i.e. the values to assign

### operator

As we saw, R's standard `<-` operator will allow us to assign a single value to multiple variables at once. Rather than jump the shark and overload the `<-` operator, *allotalot* provides an infix function `%<-%` to serve as the operator of our parallel assignment expresssions.

### left-hand side

To build the left-hand side of our expressions *allotalot* provides the `.` function. `.` allows us to build a flat or nested structure of variables names on the left-hand side of an expression. As we will see, nesting variable names on the left-hand side of an expression allows us to unpack nested values on the right-hand side.

### right-hand side

The right-hand side of the assignment expression must be a list object. *allotalot* includes a function `unpack` which forces destructuring of vectors or list-based custom objects. As we will see, these objects are not automatically unpacked.

## Examples

### Unpack a function return value

The simple python function `coords()` returns a static list of latitude, longitude coordinates. 

```{python}
def coords():
  '''A function which returns a list of 2 numbers (coordinates)'''
  return [38.061944, -122.643889]
  
lat, lng = coords()

print(lat)
print(lng)
```

In the example, the list of values returned by `coords()` is unpacked into the variables `lat` and `lng`. This instance of parallel assignment is commonly referred to as *unpacking assignment* or *destructuring assignment*.

Here is the same coordinates example redone in R.

```{R}
#' Get Coordinates
#' 
#' A function which returns a list of 2 numerics (coordinates).
#' 
coords <- function() {
  list(38.061944, -122.643889)
}

.(lat, lng) %<-% coords()

lat

lng
```

Notice the use of `.` on the left-hand side of the assignment expression. To work around the syntax imposed by R we use `.` to list multiple variable names. We also see the `%<-%` operator used in place of `<-`. Otherwise, the expression is straightforward and worthy of a shrug. Good! *allotalot* is not here to add more complexity to our code and lives.

Let's make a small change to the example and see what happens. We will also change the function name to distinguish between our original `coords` function and this new `coords2` function.

```{R, include = FALSE} 
rm(lat)
rm(lng)
```

```{R, error = TRUE}
#' Get Coordinates (again)
#' 
#' A function which returns a numeric vector of length 2, the coordinates.
#'
coords2 <- function() {
  c(38.061944, -122.643889) 
}

.(lat, lng) %<-% coords2()

lat

lng
```

Remember, vectors are not automatically unpacked. This is because `%<-%` may be used for standard assignment.

```{R}
x %<-% c(30, 30)

x
```

```{R}
.(y) %<-% c('blue', 'fish')

y
```

### Force object to unpack

To fix our `coords2` example, without changing the `coords2` function, we can use the right-hand side function `unpack`. 

```{R}
.(lat, lng) %<-% unpack(coords2())

lat

lng
```

In addition to vectors we can use `unpack` on S3 objects. For example, `unpack` will allow us to unpack the return of `summary.lm`. Unfortunately for us, and our example, `summary.lm` unpacks into 11 values. In practice, unpacking 11 values is not advised. Fortunately,
we can specify the `unpack` argument `n`. By default `n` is `NULL`, in which case all values of an object are unpacked. But, by specifying `n` we can unpack the first `n` values of our object as well as an additional value, a list containing the remaining unpacked object values.

```{R}
f <- lm(mpg ~ cyl, data = mtcars)

.(fcall, fterms, rest) %<-% unpack(summary(f), n = 2)

fcall

fterms

is.list(rest)
length(rest)  # the number of remaining values from `summary(f)`
names(rest)

# unpack 2 more values, ignore list of remaining values using ".."
.(resids, coeffs, ..) %<-% unpack(rest, n = 2)

resids

coeffs
```

### Unpack nested values

In addition to unpacking flat lists, we can unpack values in nested lists. Based on previous examples the following illustrates what we might expect from a first attempt at unpacking a nested list.

```{python, comment = '#>>>'}
nested = [4, [0, 1]]

a, b = nested

print(a)
print(b)
```

But, if we add a variable `c` and nest `b` and `c` on the left-hand side we get a different result.

```{python, comment = '#>>>'}
nested = [4, [0, 1]]

a, (b, c) = nested

print(a)
print(b)
print(c)
```

Using nested calls to the `.` function we can mimic this syntax. Here is the example redone in R.

```{R}
nested <- list(4, list(0, 1))

.(a, .(b, c)) %<-% nested

a

b

c
```

### Swapping values

One of the simple benefits of parallel assignment is swapping variable values without the use of a temporary variable.

```{R}
first <- 'Genly'
last <- 'Ai'

.(first, last) %<-% list(last, first)

first

last
```

or

```{R}
cat <- 'meow'
dog <- 'bark'

.(cat, dog, fish) %<-% list(dog, cat, dog)

cat

dog

fish
```

### Unpacking safe function values

This next example requires the purrr package. From purrr we will use the `safely` function. By passing a function to `safely`, we can create a new "safe" version of a function. This safe version always returns a list of two values. The first list item is the result of calling the original function, if no error occurred, or `NULL`. The second list item is an error, if an error occurred, or `NULL`. Whether or not the original function would have thrown an error, the safe version will never throw an error. To run the example make sure you have purrr installed.

```{R, eval = require('purrr')}
safe_log <- purrr::safely(log)

pair <- safe_log(10)

pair$result

pair$error
```

The example code is no deal breaker. But, using *allotalot* we can specify clear variable names and cut down on repititions, such as the repeated extractions from `pair`. Here is the example reworked using *allotalot*.

```{R, eval = require('purrr')}
.(res, err) %<-% safe_log(10)

res

err
```

In this example we could go a step further naming our variables. `result` and `error` are clearer and potentially better than `res` and `err`. In either case, we have the choice to use explicit variable names. Let's continue our purrr examples. In the example below, we will also use the `enumerate` helper function from *allotalot*. 

```{R, eval = require('purrr')}
x <- list(20, 'N/A', 17)

log_x <- purrr::map(x, safe_log)

log_x

for (triple in enumerate(log_x)) {
  .(i, .(res, err)) %<-% triple
  
  if (!is.null(err)) {
    message('problem with result ', i)
    next
  }
  
  message('result ', i, ' is ', res)
}
```
