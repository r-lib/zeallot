---
title: "Parallel, Multiple, and Unpacking Assignment"
author: "Nathan Teetor"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Parallel, Multiple, and Unpacking Assignment}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{R, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = '#>')
knitr::knit_theme$set('leo')

library(allotalot)
```

## Parallel Assignment

Parallel assignment is the assignment of multiple variables at once. Languages, such as Python or Go, allow parallel or unpacking assignment with syntax similar to the following.

```{python, comment = '#>>>'}
a, b = 0, 1

print(a)
print(b)
```
```{python, comment = '#>>>'}
c, d = 'red', 'fish'

print(c)
print(d)
```
```{python, comment = '#>>>'}
values = ['a', 'simple', 'list']

e, f, g = values

print(e)
print(f)
print(g)
```

In the above example we see `a` and `b` assigned on a single line, likewise `c` and `d`, and in the final example we unpack a list of values into `e`, `f`, and `g`. R allows a watered-down version of these examples, but variables must be assigned the same value. 

```{R}
a <- b <- c(0, 1)

a
b
```

```{R}
c <- d <- c('red', 'fish')

c
d
```

```{R}
e <- f <- g <- list('a', 'simple', 'list')

e
```

Now that we have seen a couple initial examples and touched on the limitations of R, we will quickly preview the tools *allotalot* provides and then look at a series of more complex and practical parallel assignment examples.

## Toolset

When we talk about a parallel assignment expression there are three components we often refer to,

1. The operator
2. The left-hand side, i.e. the variable names
3. The right-hand side, i.e. the values to assign

### operator

As we saw, R's standard `<-` operator will allow us to assign a single value to multiple variables at once. Rather than jump the shark and overload the `<-` operator, *allotalot* provides an infix function `%<-%` to serve as the operator of our parallel assignment expressions.

### left-hand side

We cannot separate variable names with commas or nest them using parentheses because of R's syntactic restrictions. Instead, to build the left-hand side of our assignment expressions we use colons and braces as a stand-in for commas and paraentheses. This syntax allows us to build a flat or nested structure of variable names on the left-hand side of an expression. As we will see, nesting variable names on the left-hand side of an expression allows us to unpack nested values on the right-hand side.

### right-hand side

The right-hand side of the assignment expression is a list, vector, or other object. If an object other than a list or vector is unpacked, the object is first coerced to a list. As we will see, different syntax is used to unpack vectors and lists, but the difference is minor. 

## Examples

### Unpack a function return value

The simple python function `coords()` returns a static list of latitude, longitude coordinates. 

```{python}
def coords():
  '''A function which returns a list of 2 numbers (coordinates)'''
  return [38.061944, -122.643889]
  
lat, lng = coords()

print(lat)
print(lng)
```

In the example, the list of values returned by `coords()` is unpacked into the variables `lat` and `lng`. This instance of parallel assignment is commonly referred to as *unpacking assignment* or *destructuring assignment*.

Here is the same coordinates example redone in R.

```{R}
#' Get Coordinates
#' 
#' A function which returns a list of 2 numerics (coordinates).
#' 
coords <- function() {
  list(38.061944, -122.643889)
}

{lat: lng} %<-% coords()

lat
lng
```

Notice the use of the colon and braces on the left-hand side of the assignment expression. Based on the left-hand side structure, the assignment operator expects `coords()` to return a list of two values. Those two values are then assigned to `lat` and `lng`.

Let's try rerunning the `coords` example, but this time without the braces.

```{R, include = FALSE} 
rm(lat)
rm(lng)
```

```{R, error = TRUE}
lat: lng %<-% coords()

lat
lng
```

To unpack a list of values, the left-hand side must be enclosed in braces. Without the braces the assignment operator expects and tries to unpack a vector of values. If we create a new function `coords2` which returns a vector, the error is fixed.

```{R}
#' Get Coordinates (again)
#' 
#' A function which returns a numeric vector of length 2, the coordinates.
#'
coords2 <- function() {
  c(-36.85, 174.77)
}

lat: lng %<-% coords2()

lat
lng
```

### Consume extra values

In some cases, there are many right-hand side values, but we only want to unpack the first couple values. `summary.lm`, for example, unpacks into 11 values. In practice, unpacking 11 values into 11 different variables is not advised. Fortunately, there is a way to assign a couple values and handle the remaining values.

```{R}
f <- lm(mpg ~ cyl, data = mtcars)

{fcall: fterms: resids: ...rest} %<-% summary(f)

fcall

fterms

resids

# `rest` is not printed here to save space, but feel
# free to run the example and look at `rest`
class(rest)
length(rest)
```

As `...` in an argument list collects extra values passed to a function, a variable prefixed with `...` in an assignment expression collects extra values. If we left off the `...` we would get an error.

```{R, error = TRUE}
{fcall: fterms: resids: rest} %<-% summary(f)
```

### Unpack nested values

In addition to unpacking flat lists, we can unpack values in nested lists. Based on previous examples the following illustrates what we might expect from a first attempt at unpacking a nested list.

```{python, comment = '#>>>'}
nested = [4, [0, 1]]

a, b = nested

print(a)
print(b)
```

But, if we add a variable `c` and nest `b` and `c` on the left-hand side we get a different result.

```{python, comment = '#>>>'}
nested = [4, [0, 1]]

a, (b, c) = nested

print(a)
print(b)
print(c)
```

We can mimic this syntax using braces instead of parentheses. Here is the example redone in R.

```{R}
nested <- list(4, list(0, 1))

{a: {b: c}} %<-% nested

a
b
c
```

### Swap values

One of the simple benefits of parallel assignment is swapping variable values without the use of a temporary variable.

```{R}
first <- 'Genly'
last <- 'Ai'

{first: last} %<-% list(last, first)

first
last
```

or

```{R}
cat <- 'meow'
dog <- 'bark'

{cat: dog: fish} %<-% list(dog, cat, dog)

cat
dog
fish
```

### Parallel assignment and *purrr*

This next example requires the *purrr* package. From *purrr* we will use the `safely` function. By passing a function to `safely`, we can create a new "safe" version of a function. This safe version always returns a list of two values. The first list item is the result of calling the original function, if no error occurred, or `NULL`. The second list item is an error, if an error occurred, or `NULL`. Whether or not the original function would have thrown an error, the safe version will never throw an error. To run the example make sure you have *purrr* installed.

```{R, eval = require('purrr')}
safe_log <- purrr::safely(log)

pair <- safe_log(10)

pair$result

pair$error
```

The example code is no deal breaker. But, using *allotalot* we can specify clear variable names and cut down on repititions, such as the repeated extractions from `pair`. Here is the example reworked using *allotalot*.

```{R, eval = require('purrr')}
{res: err} %<-% safe_log(10)

res
err
```

In this example we could go a step further naming our variables. `result` and `error` are clearer and potentially better than `res` and `err`. In either case, we have the choice to use explicit variable names. Let's continue our purrr examples. In the example below, we will also use the `enumerate` helper function from *allotalot*. 

```{R, eval = require('purrr')}
x <- list(20, 'N/A', 17)

log_x <- purrr::map(x, safe_log)

log_x

for (triple in enumerate(log_x)) {
  {i: {res: err}} %<-% triple
  
  if (!is.null(err)) {
    message('problem with result ', i)
    next
  }
  
  message('result ', i, ' is ', res)
}
```
