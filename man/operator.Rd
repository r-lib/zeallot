% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/operator.R
\name{operator}
\alias{operator}
\alias{\%<-\%}
\alias{\%->\%}
\title{Multiple assignment operators}
\usage{
x \%<-\% value

value \%->\% x
}
\arguments{
\item{x}{A name structure, see section below.}

\item{value}{A list of values, vector of values, or \R object to assign.}
}
\value{
\code{\%<-\%} and \code{\%->\%} invisibly return \code{value}.

These operators are used primarily for their assignment side-effect.
\code{\%<-\%} and \code{\%->\%} assign into the environment in which they
are evaluated.
}
\description{
Assign values to name(s).
}
\section{Name Structure}{


\strong{The basics}

At its simplest, the name structure may be a single variable name, in which
case \code{\%<-\%} and \code{\%->\%} perform regular assignment, \code{x
\%<-\% list(1, 2, 3)} or \code{list(1, 2, 3) \%->\% x}.

To specify multiple variable names use a call to \code{c()}, for example
\code{c(x, y, z) \%<-\% c(1, 2, 3)}.

When \code{value} is neither an atomic vector nor a list, \code{\%<-\%} and
\code{\%->\%} will try to destructure \code{value} into a list before assigning
variables, see \code{\link[=destructure]{destructure()}}.

\strong{Object parts}

Like assigning a variable, one may also assign part of an object, \code{c(x,
x[[1]]) \%<-\% list(list(), 1)}.

\strong{Nested names}

One can also nest calls to \code{c()} when needed, \code{c(x, c(y, z))}. This nested
structure is used to unpack nested values,
\code{c(x, c(y, z)) \%<-\% list(1, list(2, 3))}.

\strong{Collector variables}

To gather extra values from the beginning, middle, or end of \code{value} use a
collector variable. Collector variables are indicated with a \code{...}
prefix, \code{c(...start, z) \%<-\% list(1, 2, 3, 4)}.

\strong{Skipping values}

Use \code{.} in place of a variable name to skip a value without raising an error
or assigning the value, \code{c(x, ., z) \%<-\% list(1, 2, 3)}.

Use \code{...} to skip multiple values without raising an error or assigning the
values, \code{c(w, ..., z) \%<-\% list(1, NA, NA, 4)}.

\strong{Default values}

Use \code{=} with a value to specify a default value for a variable,
\code{c(x, y = NULL) \%<-\% tail(1, 2)}.

When assigning part of an object a default value may not be specified because
of the syntax enforced by \R. The following would raise an \code{"unexpected '=' ..."} error, \code{c(x, x[[1]] = 1) \%<-\% list(list())}.

\strong{Named assignment}

Use \code{=} \emph{without} a value to extract and assign values by name,
\code{c(two=, ...) \%<-\% list(one = 1, two = 2, three = 3)}.
}

\examples{
# Basic usage
c(a, b) \%<-\% list(0, 1)

a  # 0
b  # 1

# Unpack and assign nested values
c(c(e, f), c(g, h)) \%<-\% list(list(2, 3), list(3, 4))

e  # 2
f  # 3
g  # 4
h  # 5

# Can assign more than 2 values at once
c(j, k, l) \%<-\% list(6, 7, 8)

# Assign columns of data frame
c(erupts, wait) \%<-\% faithful

erupts  # 3.600 1.800 3.333 ..
wait    # 79 54 74 ..

# Assign only specific columns, skip other columns
c(mpg, cyl, disp, ...) \%<-\% mtcars

mpg   # 21.0 21.0 22.8 ..
cyl   # 6 6 4 ..
disp  # 160.0 160.0 108.0 ..

# Alternatively, assign a column by name
c(qsec=, ...) \%<-\% mtcars

qsec  # 16.46 17.02 18.61 ..

# Skip initial values, assign final value
TODOs <- list("make food", "pack lunch", "save world")

c(..., final_task) \%<-\% TODOs

final_task  # "save world"

# Assign first name, skip middle initial, assign last name
c(first_name, ., last_name) \%<-\% c("Ursula", "K", "Le Guin")

first_name  # "Ursula"
last_name   # "Le Guin"

# Simple model and summary
mod <- lm(hp ~ gear, data = mtcars)

# Extract call and fstatistic from the summary
c(call=, fstatistic=, ...) \%<-\% summary(mod)

call
fstatistic

# Unpack nested values w/ nested names
fibs <- list(1, list(2, list(3, list(5))))

c(f2, c(f3, c(f4, c(f5)))) \%<-\% fibs

f2  # 1
f3  # 2
f4  # 3
f5  # 5

# Unpack first numeric, leave rest
c(f2, fibcdr) \%<-\% fibs

f2      # 1
fibcdr  # list(2, list(3, list(5)))

# Swap values without using temporary variables
c(a, b) \%<-\% c("eh", "bee")

a  # "eh"
b  # "bee"

c(a, b) \%<-\% c(b, a)

a  # "bee"
b  # "eh"

# Unpack `strsplit` return value
names <- c("Nathan,Maria,Matt,Polly", "Smith,Peterson,Williams,Jones")

c(firsts, lasts) \%<-\% strsplit(names, ",")

firsts  # c("Nathan", "Maria", ..
lasts   # c("Smith", "Peterson", ..

# Handle missing values with default values
parse_time <- function(x) {
  strsplit(x, " ")[[1]]
}

c(hour, period = NA) \%<-\% parse_time("10:00 AM")

hour    # "10:00"
period  # "AM"

c(hour, period = NA) \%<-\% parse_time("15:00")

hour    # "15:00"
period  # NA

# Right operator
list(1, 2, "a", "b", "c") \%->\% c(x, y, ...chars)

x      # 1
y      # 2
chars  # list("a", "b", "c")

# Magrittr chains, install.packages("magrittr") for this example
if (requireNamespace("magrittr", quietly = TRUE)) {

  library(magrittr)

  c("hello", "world!") \%>\%
    paste0("\n") \%>\%
    toupper() \%->\%
    c(greeting, subject)

  greeting  # "HELLO\n"
  subject   # "WORLD!\n"

}

}
\seealso{
For more on unpacking custom objects please refer to
\code{\link[=destructure]{destructure()}}.
}
