% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unpack.R
\name{unpack}
\alias{enumerate}
\alias{items}
\alias{unpack}
\title{Destructure an Object}
\usage{
unpack(x, n = NULL)

items(x)

enumerate(x)
}
\arguments{
\item{x}{An \R object.}

\item{n}{A numeric specifying the number of elements to unpack from \code{x},
defaults to \code{NULL} in which case all elements are unpacked.}
}
\value{
For \code{unpack} a list created by \code{\link{lapply}}-ing
\code{\link{identity}} to \code{x}. If \code{n} is specified and \code{n} is
less than the number of elements in \code{x}, a list of length \code{n + 1}
where the first \code{n} elements are unpacked and the last item is a list
containing the unpacked values.

For \code{items} a list of name, value pairs, one pair for each element of
\code{x}. The name in each pair is the original name of the value in
\code{x}. See below for examples.

For \code{enumerate} a list of index, value pairs, one pair for each element
of \code{x}. The indices range from 1 to the number of elements in the
unpacked list of \code{x}.
}
\description{
The \code{unpack} function is used to force vectors and objects with custom
classes to unpack during parallel assignment. The \code{items} function
unpacks a named object into a list of name, value pairs. The \code{enumerate}
function unpacks an object into a list of index, value pairs.
}
\details{
If \code{n} is less than the number of elements in \code{x} than the first
\code{n} elements are unpacked as well as an additional value. This final
value is a list of the remaining unpacked elements of \code{x}. If \code{n}
is greater than the number of elements in \code{x} all elements are unpacked.
See below for examples.

\code{unpack} is necessary because \code{\link{\%<-\%}} can perform standard
assignment, so vectors are not automatically unpacked. In addition to
vectors, S3 objects are not automatically unpacked and \code{unpack} must be
used.
}
\examples{
# expects two values to assign to `x` and `y`,
# but the vector does not unpack
\dontrun{
.(x, y) \%<-\% c(0, 1)
}

# instead we can force the vector to unpack
.(x, y) \%<-\% unpack(c(0, 1))

# we can use unpack and specify argument `n`
# to only unpack a select number of elements

f <- lm(mpg ~ cyl, data = mtcars)

.(fcall, rest) \%<-\% unpack(summary(f), n = 1)

# this is especially useful as unpacking
# `summary.lm` returns 11 values

# the first element
fcall

# the rest of the elements bundled into
# a list
rest

# some food groups and choices
foods <- list(
  bread = c('rye', 'wheat'),
  veggies = c('peas', 'spinach', 'corn'),
  fruits = c('plums', 'cherries')
)

# we can use `items` and `enumerate` to
# unpack our list of foods
for (pair in enumerate(items(foods))) {
  .(i, .(group, choices))  \%<-\% pair
  cat(
    sprintf(
      '\%d. \%s - \%s\\n',
      i, group, paste(choices, collapse = ', ')
    )
  )
}

# more enumeration, this time unpacking the
# iris data set
for (col in enumerate(iris)) {
  .(i, values) \%<-\% col

  if (i != 5) {
    cat('mean', i, 'is', mean(values), '\\n')
  }
}

}

